



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>4152 - SJTUOJ解答集</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#4152-cantor" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="SJTUOJ解答集" aria-label="SJTUOJ解答集" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              SJTUOJ解答集
            </span>
            <span class="md-header-nav__topic">
              
                4152
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SJTU-OJ/SJTU-OJ.github.io
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="SJTUOJ解答集" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    SJTUOJ解答集
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SJTU-OJ/SJTU-OJ.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="主页" class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../" title="索引" class="md-nav__link">
      索引
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../add/" title="添加" class="md-nav__link">
      添加
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../thanks/" title="鸣谢" class="md-nav__link">
      鸣谢
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ligongzzzs-solution" class="md-nav__link">
    ligongzzz's solution 
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neight99s-solution" class="md-nav__link">
    Neight99's solution 
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#washswangs-solution" class="md-nav__link">
    WashSwang's solution 
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/edit/master/docs/nr/4152.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <script async defer src="https://buttons.github.io/buttons.js"></script>

<h1 id="4152-cantor">4152 Cantor表</h1>
<p><details>
<summary><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4152">题目</a></summary></p>
<article class="span9">
 <h2>
  Description
 </h2>
 <p>
  集合论的创立人 Georg Cantor 曾给出一个表证明了有理数是可列的, 如下面所示:
 </p>
 <pre><code>1/1 1/2 1/3 1/4 1/5 ...
2/1 2/2 2/3 2/4 ...
3/1 3/2 3/3 ... 
4/1 4/2 ...
5/1 ...
</code></pre>
 <p>
  按顺序列出来就是 1/1, 1/2, 2/1, 3/1, 2/2, 1/3, 1/4, 2/3, ..., 现在给你一个正整数 n, 求第 n 项.
 </p>
 <h2>
  Input Format
 </h2>
 <p>
  一行一个正整数 n, 表示所求的项数.
 </p>
 <h2>
  Output Format
 </h2>
 <p>
  一个 a/b 式的正有理数, 表示表中的第 n 项.
 </p>
 <h2>
  Sample Input
 </h2>
 <pre><code>11
</code></pre>
 <h2>
  Sample Output
 </h2>
 <pre><code>5/1
</code></pre>
 <h2>
  Hint
 </h2>
 <p>
  对 40% 的数据, 1&lt;=n&lt;=10^6;
 </p>
 <p>
  对 70% 的数据, 1&lt;=n&lt;=10^18;
 </p>
 <p>
  对 90% 的数据, 1&lt;=n&lt;=10^100;
 </p>
 <p>
  对 100% 的数据,1&lt;=n&lt;=10^1000.
 </p>
</article>

</details>

<h2 id="ligongzzzs-solution">ligongzzz's solution <a class="github-button" href="https://github.com/ligongzzz/SJTU-OJ" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>#include &quot;iostream&quot;
#include &quot;cstring&quot;
#include &quot;algorithm&quot;
using namespace std;

//常数
constexpr auto maxNum = 10000;
constexpr auto intMax = 20;

//新无符号大整数类

class unsignedBigInt {
private:
    bool del = false;
public:
    char *ch;
    int startNum = 0;
    int len = 0;

    //初始化
    unsignedBigInt(const char *input) {
        if (del)
            delete[] ch;

        len = (strlen(input) + 1) * 2;
        startNum = strlen(input);
        ch = new char[len];
        memset(ch, 0, len);
        for (int i = 0; i &lt; strlen(input); i++)
            ch[i + startNum] = input[i];

        del = true;
    }
    unsignedBigInt(int num) {
        if (del)
            delete[] ch;

        //临时数组
        int n = 0, temp[intMax];
        if (num == 0) {
            n = 1;
            temp[0] = 0;
        }
        else
            for (; num &gt; 0; num /= 10)
                temp[n++] = num % 10;


        len = (n + 1) * 2;
        startNum = n;
        ch = new char[len];
        memset(ch, 0, len);

        for (int i = 0; i &lt; n; i++)
            ch[startNum + i] = temp[n - i - 1] + '0';

        del = true;
    }
    unsignedBigInt(void) {
        if (del)
            delete[] ch;

        len = 1;
        startNum = 0;
        ch = new char[len];
        memset(ch, 0, len);

        del = true;
    }
    unsignedBigInt(int num, int sizen) {
        if (del)
            delete[] ch;

        len = (sizen + 1) * 2;
        startNum = sizen;
        ch = new char[len];
        memset(ch, 0, len);

        if (num &gt;= 0) {
            int n = 0, temp[intMax];
            if (num == 0) {
                n = 1;
                temp[0] = 0;
            }
            else
                for (; num &gt; 0; num /= 10)
                    temp[n++] = num % 10;

            for (int i = 0; i &lt; n; i++)
                ch[startNum + i] = temp[n - i - 1] + '0';
        }

        del = true;
    }

    //析构
    ~unsignedBigInt() {
        if (del)
            delete[] ch;
    }

    //计算真实长度
    int realLength(const unsignedBigInt &amp;b) {
        return strlen(b.ch + b.startNum);
    }

    //复制构造函数
    unsignedBigInt(const unsignedBigInt&amp; b) {
        if (del)
            delete[] ch;

        len = b.len;
        startNum = b.startNum;
        ch = new char[len];
        for (int i = 0; i &lt; len; i++)
            ch[i] = b.ch[i];

        del = true;
    }

    //输入输出
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const unsignedBigInt &amp;bi);
    friend istream &amp;operator&gt;&gt;(istream &amp;input, unsignedBigInt &amp;bi);

    //赋值
    unsignedBigInt &amp;operator=(const unsignedBigInt &amp;b) {
        //检查自身赋值
        if (this == &amp;b)
            return *this;

        if (del)
            delete[] ch;

        len = b.len;
        startNum = b.startNum;
        ch = new char[len];
        for (int i = 0; i &lt; len; i++)
            ch[i] = b.ch[i];

        del = true;
        return *this;
    }
    unsignedBigInt &amp;operator=(const char* b) {
        if (del)
            delete[] ch;

        len = (strlen(b) + 1) * 2;
        startNum = strlen(b);
        memset(ch, 0, len);

        for (int i = 0; i &lt; strlen(b); i++)
            ch[i + startNum] = b[i];

        del = true;
        return *this;
    }
    unsignedBigInt &amp;operator=(int num) {
        if (del)
            delete[] ch;

        //临时数组
        int n = 0, temp[intMax];
        if (num == 0) {
            n = 1;
            temp[0] = 0;
        }
        else
            for (; num &gt; 0; num /= 10)
                temp[n++] = num % 10;


        len = (n + 1) * 2;
        startNum = n;
        ch = new char[len];
        memset(ch, 0, len);

        for (int i = 0; i &lt; n; i++)
            ch[startNum + i] = temp[n - i - 1] + '0';

        del = true;
        return *this;
    }

    //比较符
    //小于
    bool operator&lt;(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt; strlen(b.ch + b.startNum) ? true : false;
    }

    //大于
    bool operator&gt;(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &gt; strlen(b.ch + b.startNum) ? true : false;
    }

    //小于等于
    bool operator&lt;=(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt; strlen(b.ch + b.startNum) ? true : false;
    }

    //大于等于
    bool operator&gt;=(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &gt; strlen(b.ch + b.startNum) ? true : false;
    }

    //等于等于
    bool operator==(const unsignedBigInt &amp;b) {
        return strcmp(ch + startNum, b.ch + b.startNum) == 0 ? true : false;
    }

    //运算符
    //加号
    unsignedBigInt operator+(const unsignedBigInt &amp;b) {
        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        int jw = 0;
        int test = realLength(*this);

        for (int i = 0; realLength(*this) &gt; i || realLength(b) &gt; i || jw != 0; i++) {
            //判断加数
            int j1 = realLength(*this) &lt;= i ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2 = realLength(b) &lt;= i ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            temp.ch[--temp.startNum] = (j1 + j2 + jw) % 10 + '0';
            jw = (j1 + j2 + jw) / 10;
        }

        //返回
        return temp;
    }

    //++c
    unsignedBigInt operator++() {
        *this = *this + unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c++
    unsignedBigInt operator++(int i) {
        unsignedBigInt temp = *this;
        *this = temp + unsignedBigInt(&quot;1&quot;);
        return temp;
    }

    //减号
    unsignedBigInt operator-(const unsignedBigInt &amp;b) {
        if (*this == b)
            return unsignedBigInt(0);

        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        int jw = 0;

        for (int i = 0; realLength(*this) &gt; i || realLength(b) &gt; i; i++) {
            //判断被减数与减数
            int j1 = realLength(*this) &lt;= i ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2 = realLength(b) &lt;= i ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            if (j1 - jw - j2 &lt; 0) {
                temp.ch[--temp.startNum] = 10 + j1 - jw - j2 + '0';
                jw = 1;
            }
            else {
                temp.ch[--temp.startNum] = j1 - jw - j2 + '0';
                jw = 0;
            }
        }

        //修正
        for (; temp.ch[temp.startNum] == '0';)
            temp.ch[temp.startNum++] = 0;

        //返回
        return temp;
    }

    //--c
    unsignedBigInt operator--() {
        *this = *this - unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c--
    unsignedBigInt operator--(int i) {
        unsignedBigInt temp = *this;
        *this = temp - unsignedBigInt(&quot;1&quot;);
        return temp;
    }

    //乘号
    unsignedBigInt operator*(const unsignedBigInt &amp;b) {
        unsignedBigInt temp(0, realLength(*this) + realLength(b) + 2);
        for (int i = 0; i &lt; strlen(b.ch + b.startNum); i++) {
            int curPos = b.startNum + strlen(b.ch + b.startNum) - 1 - i;
            unsignedBigInt addNum(-1, realLength(*this) + realLength(b) + 2);
            if (b.ch[curPos] != '0') {
                //Accelerate
                int jw = 0;
                for (int j = startNum + strlen(ch + startNum) - 1; j &gt;= startNum || jw != 0; j--) {
                    int c1 = ch[j] == 0 ? 0 : ch[j] - '0';
                    int c2 = b.ch[curPos] == 0 ? 0 : b.ch[curPos] - '0';

                    if (c1*c2 + jw &lt; 10) {
                        addNum.ch[--addNum.startNum] = c1 * c2 + jw + '0';
                        jw = 0;
                    }
                    else {
                        addNum.ch[--addNum.startNum] = (c1*c2 + jw) % 10 + '0';
                        jw = (c1*c2 + jw) / 10;
                    }
                }
                //Calculate
                for (int j = 0; j &lt; i; j++)
                    addNum.ch[addNum.startNum + strlen(addNum.ch + addNum.startNum)] = '0';

                temp = temp + addNum;
            }
        }
        return temp;
    }

    //除号
    unsignedBigInt operator/(const unsignedBigInt &amp;b) {
        //排除异常
        if (unsignedBigInt(&quot;0&quot;) == b) {
            throw &quot;NaN&quot;;
        }

        //临时被除数
        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        //最终结果
        unsignedBigInt result(-1, max(realLength(*this), realLength(b)) + 2);

        for (int i = startNum; i &lt; startNum + strlen(ch + startNum); i++) {
            //下移一位
            temp.ch[temp.startNum + strlen(temp.ch + temp.startNum)] = ch[i];
            //开始计算
            unsignedBigInt tempResult = b;
            int wr = 0;
            for (; tempResult &lt;= temp; wr++) {
                tempResult = tempResult + b;
            }
            result.ch[result.startNum + strlen(result.ch + result.startNum)] = wr + '0';
            //计算差值
            tempResult = tempResult - b;
            if (tempResult == temp) {
                temp = unsignedBigInt(-1, max(realLength(*this), realLength(b)) + 2);
            }
            else {
                temp = temp - tempResult;
            }
        }

        //去0
        for (; strlen(result.ch + result.startNum) &gt; 1 &amp;&amp; result.ch[result.startNum] == '0';)
            result.ch[result.startNum++] = 0;

        return result;
    }

    //%
    unsignedBigInt operator%(const unsignedBigInt &amp;b) {
        return *this - *this / b * b;
    }

    //+=
    void operator+=(const unsignedBigInt &amp;b) {
        *this = *this + b;
    }

    //-=
    void operator-=(const unsignedBigInt &amp;b) {
        *this = *this - b;
    }

    //*=
    void operator*=(const unsignedBigInt &amp;b) {
        *this = *this * b;
    }

    // /=
    void operator/=(const unsignedBigInt &amp;b) {
        *this = *this / b;
    }

    //%=
    void operator%=(const unsignedBigInt &amp;b) {
        *this = *this% b;
    }
};

//输入输出流重载
//无符号大整数
ostream &amp;operator&lt;&lt;(ostream &amp;output, const unsignedBigInt &amp;bi) {
    output &lt;&lt; bi.ch + bi.startNum;
    return output;
}
istream &amp;operator&gt;&gt;(istream &amp;input, unsignedBigInt &amp;bi) {
    char ch[maxNum];
    input &gt;&gt; ch;
    bi = unsignedBigInt(ch);
    return input;
}

int main() {

    char ch[2000] = { 0 };
    cin &gt;&gt; ch;

    unsignedBigInt input(ch);
    //cout &lt;&lt; &quot;输入的数据是：&quot; &lt;&lt; endl&lt;&lt;input &lt;&lt; endl;

    //开根号
    int cnt = 0;
    ch[strlen(ch) / 2] = 0;
    unsignedBigInt temp1 = input * 2, temp = ch, y, jd(&quot;999999&quot;);

    for (; cnt &lt; 1000; cnt++) {
        if (y &lt; temp&amp;&amp;temp - y &lt; jd)
            break;
        else if (y &gt;= temp &amp;&amp; y - temp &lt; jd)
            break;
        y=temp;
        temp = (temp + temp1 / temp) / 2;
    }
    //cout &lt;&lt; &quot;循环了&quot; &lt;&lt; cnt &lt;&lt; &quot;次&quot; &lt;&lt; endl;
    unsignedBigInt i = temp, j = (temp+1)*temp/2;
    //cout &lt;&lt; i &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;
    if (j &lt; input)
        for (; j &lt; input; j += i)
            ++i;
    else {
        for (; j &gt;= input; i--)
            j -= i;
        ++i;
        j += i;
    }

    if (i % 2 == 1)
        cout &lt;&lt; j + 1 - input &lt;&lt; &quot;/&quot; &lt;&lt; input + i - j;
    else
        cout &lt;&lt; input + i - j &lt;&lt; &quot;/&quot; &lt;&lt; j + 1 - input;

    return 0;
}
</code></pre>

<h2 id="neight99s-solution">Neight99's solution <a class="github-button" href="https://github.com/Neight99/SJTU_DataStructure_A" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>#include &lt;cstring&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;

class bigint {
   private:
    static const int base = 1e8, pow = 8;
    long long data[1000];
    int length;

   public:
    bigint();
    bigint(const char *);
    bigint(const bigint &amp;);
    void operator+=(const long long &amp;);
    bigint operator+(const bigint &amp;) const;
    void operator+=(const bigint &amp;);
    bigint operator-(const bigint &amp;) const;
    void operator-=(const bigint &amp;);
    void operator*=(const bigint &amp;);
    bigint operator*(const bigint &amp;)const;
    void operator*=(const long long &amp;);
    bigint operator*(const long long &amp;)const;
    void operator/=(const long long &amp;);
    bigint operator/(const long long &amp;) const;
    bigint operator=(const bigint &amp;);
    bool operator&lt;(const bigint &amp;) const;
    bool operator&lt;=(const bigint &amp;) const;
    bool operator==(const bigint &amp;) const;
    bool operator&gt;(const bigint &amp;) const;
    int mod2() const;
    void output() const;
};

bigint::bigint() : length(0) { memset(data, 0, sizeof(data)); }

bigint::bigint(const char *str) {
    memset(data, 0, sizeof(data));
    int len = strlen(str);
    for (int i = 0; i &lt; len; i++) {
        data[(len - i - 1) / 8] = data[(len - i - 1) / 8] * 10 + str[i] - '0';
    }
    length = (len - 1) / 8 + 1;
}

bigint::bigint(const bigint &amp;right) {
    if (this != &amp;right) {
        memset(data, 0, sizeof(data));
        length = right.length;
        for (int i = 0; i &lt; length; i++) {
            data[i] = right.data[i];
        }
    }
}

bigint bigint::operator=(const bigint &amp;right) {
    if (this != &amp;right) {
        memset(data, 0, sizeof(data));
        length = right.length;
        for (int i = 0; i &lt; length; i++) {
            data[i] = right.data[i];
        }
    }

    return *this;
}

void bigint::operator+=(const long long &amp;right) {
    data[0] += right;
    for (int i = 0; i &lt; length; i++) {
        data[i + 1] += data[i] / base;
        data[i] %= base;
    }
    while (data[length] &gt; 0) {
        length++;
    }
}

void bigint::operator+=(const bigint &amp;right) {
    length = (length &gt; right.length) ? length : right.length;
    for (int i = 0; i &lt; length; i++) {
        data[i] += right.data[i];
        data[i + 1] += data[i] / base;
        data[i] %= base;
    }

    while (data[length] &gt; 0) {
        length++;
    }
}

bigint bigint::operator+(const bigint &amp;right) const {
    bigint temp = *this;
    temp += right;

    return temp;
}

void bigint::operator-=(const bigint &amp;right) {
    for (int i = 0; i &lt; length; i++) {
        data[i] -= right.data[i];
        while (data[i] &lt; 0) {
            data[i] += base;
            data[i + 1]--;
        }
    }

    while (data[length - 1] &lt;= 0 &amp;&amp; length &gt; 0) {
        --length;
    }
}

bigint bigint::operator-(const bigint &amp;right) const {
    bigint temp = *this;
    temp -= right;
    return temp;
}

bigint bigint::operator*(const bigint &amp;right) const {
    bigint temp;
    temp.length = length + right.length - 1;

    for (int i = 0; i &lt; length; i++) {
        for (int j = 0; j &lt; right.length; j++) {
            temp.data[i + j] += data[i] * right.data[j];
        }
    }
    for (int i = 0; i &lt; temp.length; i++) {
        temp.data[i + 1] += temp.data[i] / base;
        temp.data[i] %= base;
    }

    while (temp.data[temp.length] &gt; 0) {
        temp.length++;
        temp.data[temp.length] += temp.data[temp.length - 1] / base;
        temp.data[temp.length - 1] %= base;
    }

    return temp;
}

void bigint::operator*=(const bigint &amp;right) {
    bigint temp = *this;
    temp = temp * right;
    *this = temp;
}

void bigint::operator*=(const long long &amp;right) {
    for (int i = 0; i &lt; length; i++) {
        data[i] *= right;
    }
    for (int i = 1; i &lt; length; i++) {
        data[i + 1] += data[i] / base;
        data[i] %= base;
    }
}

bigint bigint::operator*(const long long &amp;right) const {
    bigint temp = *this;
    temp *= right;
    return temp;
}

void bigint::operator/=(const long long &amp;right) {
    bigint base1(&quot;100000000&quot;);
    for (int i = length - 1; i &gt; 0; i--) {
        data[i - 1] += (data[i] % right * base);
        data[i] /= right;
    }
    data[0] /= right;

    while (length &gt; 0 &amp;&amp; data[length - 1] &lt;= 0) {
        length--;
    }
}

bigint bigint::operator/(const long long &amp;right) const {
    bigint temp = *this;
    temp /= right;

    return temp;
}

int bigint::mod2() const { return data[0] % 2; }

bool bigint::operator&lt;(const bigint &amp;right) const {
    if (length != right.length) {
        return length &lt; right.length;
    }

    for (int i = length - 1; i &gt;= 0; i--) {
        if (data[i] != right.data[i]) {
            return data[i] &lt; right.data[i];
        }
    }
    return 0;
}

bool bigint::operator&lt;=(const bigint &amp;right) const {
    return (*this &lt; right) || (*this == right);
}

bool bigint::operator==(const bigint &amp;right) const {
    if (length != right.length) {
        return 0;
    } else {
        for (int i = 0; i &lt; length; i++) {
            if (data[i] != right.data[i]) {
                return 0;
            }
        }
        return 1;
    }
}

bool bigint::operator&gt;(const bigint &amp;right) const {
    return (!(*this &lt; right)) &amp;&amp; (!(*this == right));
}

void bigint::output() const {
    printf(&quot;%lld&quot;, data[length - 1]);
    for (int i = length - 2; i &gt;= 0; i--) {
        printf(&quot;%08lld&quot;, data[i]);
    }
}

bool check(bigint &amp;N, bigint &amp;mid) {
    bigint one(&quot;1&quot;);
    if (mid * (mid + one) / 2 &lt; N) {
        return 1;
    } else {
        return 0;
    }
}

int main() {
    char n[10000];
    scanf(&quot;%s&quot;, n);
    bigint N(n), N1 = N, one(&quot;1&quot;), zero(&quot;0&quot;), line;

    while (zero &lt;= N1) {
        bigint mid = (zero + N1) / 2;
        if (check(N, mid)) {
            zero = mid + one;
            line = mid;
        } else {
            N1 = mid - one;
        }
    }
    line += one;

    if (line.mod2() != 0) {
        bigint temp1 = (line * (line + one)) / 2,
               temp2 = (((line - one) * line) / 2);
        bigint temp3 = N - temp2, temp4 = line + one - temp3;
        temp4.output();
        printf(&quot;%c&quot;, '/');
        temp3.output();
    } else {
        bigint temp1 = (line * (line + one)) / 2,
               temp2 = (((line - one) * line) / 2);
        bigint temp3 = N - temp2, temp4 = line + one - temp3;
        temp3.output();
        printf(&quot;%c&quot;, '/');
        temp4.output();
    }

    return 0;
}
</code></pre>

<h2 id="washswangs-solution">WashSwang's solution <a class="github-button" href="https://github.com/WashSwang/SJTUOJ" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;iomanip&gt;

using namespace std;
const int p=1000000000;
//Attention! This class is not complete (It may make mistakes if you apply it in other problems).
class longint{

    long long num[3000];
    int len;
public:
    longint(){
        memset(num,0,sizeof(num));
        len=1;
    };

    longint(const char *s){
        memset(num,0,sizeof(num));
        int l=(strlen(s)-1)/9+1,length=strlen(s);
        for (int i=0;i&lt;l;++i){
            for (int j=length-9*i-9;j&lt;length-9*i;++j)
            if (j&gt;=0)
                num[i]=num[i]*10+s[j]-48;
        }
        len=l;
    }

    longint(int x){
        memset(num,0,sizeof(num));
        len=0;
        while (x!=0)
        {
            num[len++]=x%p;
            x/=p;
        }
    }

    longint(const longint &amp;a):len(a.len){
        memset(num,0,sizeof(num));
        for (int i=0;i&lt;a.len;++i)
            num[i]=a.num[i];
    }

    longint &amp;operator=(const longint&amp; a){
        memset(num,0,sizeof(num));
        len=a.len;
        for (int i=0;i&lt;a.len;++i)
            num[i]=a.num[i];
        return *this;
    }

    friend longint operator+(const longint&amp; a,const longint&amp; b){
        long long c=0;
        longint r;
        r.len=max(a.len,b.len);
        for (int i=0;i&lt;r.len;++i){
            r.num[i]=a.num[i]+b.num[i]+c;
            c=r.num[i]/p;
            r.num[i]%=p;
        }
        if (c&gt;0) r.num[r.len++]=c;
        return r;
    }

    friend longint operator-(const longint&amp; a,const longint&amp; b){
        int c=0;
        longint r;
        r.len=max(a.len,b.len);
        for (int i=0;i&lt;max(a.len,b.len);++i){
            r.num[i]=a.num[i]-b.num[i]-c;
            c=0;
            if (r.num[i]&lt;0){
                r.num[i]+=p;
                c=1;
            }
        }
        while (r.len&gt;1&amp;&amp;!r.num[r.len-1]) r.len--;
        return r;
    }

    friend longint operator*(const longint&amp; a,const longint&amp; b){
        long long c=0,pos;
        int x=0;
        longint r;
        for (int i=0;i&lt;b.len;++i){
            x=i;
            c=0;
            longint tmp;
            for (int j=0;j&lt;a.len;++j){
                pos=a.num[j]*b.num[i]+c;
                c=pos/p;
                tmp.num[x]=pos%p;
                x++;
            }
            tmp.len=x;
            if (c&gt;0) tmp.num[tmp.len++]=c;
            r=r+tmp;
        }
        return r;
    }

    friend longint div(const longint&amp; a){
        longint r;
        long long x=0;
        for (int i=a.len-1;i&gt;=0;i--){
            x=x*p+a.num[i];
            r.num[i]=x/2;
            x%=2;
        }
        r.len=a.len;
        if (!r.num[r.len-1]) r.len--;
        return r;
    }

    friend bool operator&gt;(const longint&amp; a,const longint&amp; b){
        if (a.len&gt;b.len) return true;
        if (a.len&lt;b.len) return false;
        for (int i=a.len-1;i&gt;=0;--i){
            if (a.num[i]&gt;b.num[i]) return true;
            if (a.num[i]&lt;b.num[i]) return false;
        }
        return false;
    }

    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const longint &amp;a){
        os.fill('0');
        os&lt;&lt;a.num[a.len-1];
        for (int i=a.len-2;i&gt;=0;--i) {
            os&lt;&lt;setw(9)&lt;&lt;a.num[i];
        }
        return os;
    }

    friend bool odd(longint &amp;a){
        return a.num[0]%2!=0;
    }
};
char s[2000];
int main() {
    cin&gt;&gt;s;
    longint l,r(s),t(s),n(s),mid;
    r=(r-1)*2;
    t=(t-1)*2;
    while (!(l&gt;r)){
        mid=div(l+r);
        if (mid*(mid+1)&gt;t) r=mid-1;
        else l=mid+1;
    }
    l=l-1;
    n=n-div(l*(l+1));
    if (odd(l))
        cout&lt;&lt;n&lt;&lt;&quot;/&quot;&lt;&lt;l+2-n;
    else
        cout&lt;&lt;l+2-n&lt;&lt;&quot;/&quot;&lt;&lt;n;
    return 0;
}

</code></pre>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
    
  </body>
</html>