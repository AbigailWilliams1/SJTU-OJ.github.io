



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>1016 - SJTUOJ解答集</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#1016" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="SJTUOJ解答集" aria-label="SJTUOJ解答集" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              SJTUOJ解答集
            </span>
            <span class="md-header-nav__topic">
              
                1016
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SJTU-OJ/SJTU-OJ.github.io
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="SJTUOJ解答集" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    SJTUOJ解答集
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    SJTU-OJ/SJTU-OJ.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="主页" class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../" title="索引" class="md-nav__link">
      索引
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../add/" title="添加" class="md-nav__link">
      添加
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../thanks/" title="鸣谢" class="md-nav__link">
      鸣谢
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#fineartzs-solution" class="md-nav__link">
    FineArtz's solution 
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ligongzzzs-solution" class="md-nav__link">
    ligongzzz's solution 
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#neight99s-solution" class="md-nav__link">
    Neight99's solution 
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/SJTU-OJ/SJTU-OJ.github.io/edit/master/docs/nr/1016.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <script async defer src="https://buttons.github.io/buttons.js"></script>

<h1 id="1016">1016 高精度除法</h1>
<p><details>
<summary><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1016">题目</a></summary></p>
<article class="span9">
 <h2>
  Description
 </h2>
 <p>
  输入2个整数a和b，输出\( a/b \)。
 </p>
 <h2>
  Input Format
 </h2>
 <p>
  输入有两行，第一行a，第二行b。
\( 0 \leq a , b \leq 2^{1000} \)。
 </p>
 <h2>
  Output Format
 </h2>
 <p>
  输出只有一行，\( a/b \)。
 </p>
 <h2>
  Sample Input
 </h2>
 <pre><code>6
3
</code></pre>
 <h2>
  Sample Output
 </h2>
 <pre><code>2
</code></pre>
</article>

</details>

<h2 id="fineartzs-solution">FineArtz's solution <a class="github-button" href="https://github.com/FineArtz/SJTUOJ" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>/* 高精度除法 */
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

constexpr int MAXL = 1000;

class BigInt{
    //friend
    friend BigInt operator /(const BigInt&amp;, const BigInt&amp;);
    friend BigInt operator -(const BigInt&amp;, const BigInt&amp;);
    //friend bool operator &gt;(const BigInt&amp;, const BigInt&amp;);
    //friend bool operator ==(const BigInt&amp;, const BigInt&amp;);
    //friend bool operator &gt;=(const BigInt&amp;, const BigInt&amp;);
    //friend ostream&amp; operator &lt;&lt;(ostream&amp;, const BigInt&amp;);
    //friend istream&amp; operator &gt;&gt;(istream&amp;, BigInt&amp;);
public:
    //constructor
    BigInt() = default;
    BigInt(const string&amp;);
    BigInt(const BigInt&amp;);

    int operator [](const int &amp;x) const {return data[x];}
    int GetLen() const {return len;}
    BigInt lshift10(const int&amp;) const;
private:
    int len = 1;
    int data[MAXL] = {0};
};
BigInt::BigInt(const string &amp;s){
    len = s.size();
    for (int i = 1; i &lt;= len; ++i)
        data[i] = s[len - i] - '0';
}
BigInt::BigInt(const BigInt &amp;b){
    len = b.len;
    for (int i = 1; i &lt;= len; ++i)
        data[i] = b.data[i];
}
bool operator ==(const BigInt &amp;lhs, const BigInt &amp;rhs){
    if (lhs.GetLen() != rhs.GetLen()) return false;
    for (int i = 1; i &lt;= lhs.GetLen(); ++i)
        if (lhs[i] != rhs[i]) return false;
    return true;
}
bool operator &gt;(const BigInt &amp;lhs, const BigInt &amp;rhs){
    if (lhs.GetLen() &lt; rhs.GetLen()) return false;
    if (lhs.GetLen() &gt; rhs.GetLen()) return true;
    for (int i = lhs.GetLen(); i &gt;= 1; --i){
        if (lhs[i] &gt; rhs[i]) return true;
        if (lhs[i] &lt; rhs[i]) return false;
    }
    return false;
}
bool operator &gt;=(const BigInt &amp;lhs, const BigInt &amp;rhs){
    if (lhs == rhs || lhs &gt; rhs) return true;
    return false;
}
ostream&amp; operator &lt;&lt;(ostream &amp;os, const BigInt &amp;bi){
    for (int i = bi.GetLen(); i &gt;= 1; --i)
        os &lt;&lt; bi[i];
    return os;
}
BigInt operator -(const BigInt &amp;lhs, const BigInt &amp;rhs){
    BigInt ret(lhs);
    for (int i = 1; i &lt;= rhs.len; ++i)
        ret.data[i] -= rhs[i];
    for (int i = 1; i &lt;= ret.len; ++i){
        if (ret.data[i] &lt; 0){
            ret.data[i] += 10;
            --ret.data[i + 1];
        }
    }
    int i = ret.len;
    while (i &gt;= 1 &amp;&amp; ret.data[i] == 0) --i;
    ret.len = (i != 0) ? i : 1;
    return ret;
}
BigInt BigInt::lshift10(const int &amp;x) const{
    if (x &lt;= 0) return *this;
    BigInt tmp(*this);
    for (int i = len + x; i &gt;= x + 1; --i)
        tmp.data[i] = tmp[i - x];
    for (int i = 1; i &lt;= x; ++i)
        tmp.data[i] = 0;
    tmp.len += x;
    return tmp;
}
BigInt operator /(const BigInt &amp;lhs, const BigInt &amp;rhs){
    BigInt ret, tmp(lhs);
    while(tmp &gt; rhs){
        int i = 0;
        while (tmp &gt; rhs.lshift10(i + 1)) ++i;
        if (i &gt;= ret.len) ret.len = i + 1;
        while (tmp &gt; rhs.lshift10(i)){
            tmp = tmp - rhs.lshift10(i);
            ++ret.data[i + 1];
        }
    }
    if (tmp &gt;= rhs) ++ret.data[1];
    for (int i = 1; i &lt;= ret.len - 1; ++i)
        if (ret[i] &gt;= 10){
            ret.data[i] -= 10;
            ++ret.data[i + 1];
        }
    if (ret[ret.len] &gt;= 10){
        ret.data[ret.len] -= 10;
        ++ret.data[++ret.len];
    }
    return ret;
}
int main(){
    string s1, s2;
    cin &gt;&gt; s1 &gt;&gt; s2;
    BigInt bi1(s1), bi2(s2);
    cout &lt;&lt; bi1 / bi2 &lt;&lt; endl;
    return 0;
}

</code></pre>

<h2 id="ligongzzzs-solution">ligongzzz's solution <a class="github-button" href="https://github.com/ligongzzz/SJTU-OJ" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>#include &quot;iostream&quot;
#include &quot;cstring&quot;
#include &quot;cmath&quot;
#include &quot;algorithm&quot;

using namespace std;

//常数
constexpr auto maxNum = 10000;
constexpr auto intMax = 20;

//交换
template &lt;class T&gt;
void mySwap(T&amp;a, T &amp;b) {
    T temp = a;
    a = b;
    b = temp;
}

//冒泡排序
//默认a至b升序
template &lt;class T&gt;
void bubbleSort(T *destination, T *source, int num, bool(*f)(const T&amp; a, const T&amp; b)) {
    //复制
    if (destination != source)
        for (int i = 0; i &lt; num; i++)
            destination[i] = source[i];

    for (int i = num - 2; i &gt;= 0; i--)
        for (int j = 0; j &lt;= i; j++)
            if (!f(destination[j], destination[j + 1]))
                mySwap(destination[j], destination[j + 1]);
}

//无符号大整数类
/*
class unsignedBigInt {
public:
    char ch[maxNum * 2];
    int startNum = maxNum;

    //初始化
    unsignedBigInt(const char *input) {
        memset(ch, 0, maxNum*2);
        for (int i = 0; i &lt; strlen(input); i++)
            ch[i+maxNum] = input[i];
    }
    unsignedBigInt(void) {
        memset(ch, 0, maxNum*2);
    }

    //复制构造函数
    unsignedBigInt(const unsignedBigInt&amp; b) {
        for (int i = 0; i &lt; maxNum * 2; i++)
            ch[i] = b.ch[i];
        startNum = b.startNum;
    }

    //输入输出
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output,const unsignedBigInt &amp;bi);
    friend istream &amp;operator&gt;&gt;(istream &amp;input,unsignedBigInt &amp;bi);

    //赋值
    unsignedBigInt operator=(unsignedBigInt b) {
        for (int i = 0; i &lt; maxNum * 2; i++)
            ch[i] = b.ch[i];
        startNum = b.startNum;
        return *this;
    }

    //比较符
    //小于
    bool operator&lt;(unsignedBigInt b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt; strlen(b.ch + b.startNum) ? true : false;
    }

    //大于
    bool operator&gt;(unsignedBigInt b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum)&gt;strlen(b.ch + b.startNum) ? true : false;
    }

    //小于等于
    bool operator&lt;=(unsignedBigInt b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt;strlen(b.ch + b.startNum) ? true : false;
    }

    //大于等于
    bool operator&gt;=(unsignedBigInt b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &gt; strlen(b.ch + b.startNum) ? true : false;
    }

    //等于等于
    bool operator==(unsignedBigInt b) {
        return strcmp(ch + startNum, b.ch + b.startNum) == 0 ? true : false;
    }

    //运算符
    //加号
    unsignedBigInt operator+(unsignedBigInt b) {
        unsignedBigInt temp;
        int jw = 0;

        for (int i = 0;ch[startNum+strlen(ch+startNum)-i-1]!=0||b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] != 0||jw!=0; i++) {
            //判断加数
            int j1 = ch[startNum + strlen(ch + startNum) - i - 1] == 0 ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2= b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] == 0 ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            temp.ch[--temp.startNum] = (j1 + j2 + jw) % 10+'0';
            jw = (j1 + j2 + jw) / 10;
        }

        //返回
        return temp;
    }

    //++c
    unsignedBigInt operator++() {
        *this = *this + unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c++
    unsignedBigInt operator++(int i) {
        unsignedBigInt temp = *this;
        *this = temp +unsignedBigInt(&quot;1&quot;);
        return temp;
    }

    //减号
    unsignedBigInt operator-(unsignedBigInt b) {
        unsignedBigInt temp;
        int jw = 0;

        for (int i = 0; ch[startNum + strlen(ch + startNum) - i - 1] != 0 || b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] != 0; i++) {
            //判断被减数与减数
            int j1 = ch[startNum + strlen(ch + startNum) - i - 1] == 0 ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2 = b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] == 0 ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            if (j1 - jw - j2 &lt; 0) {
                temp.ch[--temp.startNum] = 10 + j1 - jw - j2 + '0';
                jw = 1;
            }
            else {
                temp.ch[--temp.startNum] =  j1 - jw - j2 + '0';
                jw = 0;
            }
        }

        //修正
        for (;temp.ch[temp.startNum] == '0';)
            temp.ch[temp.startNum++] = 0;

        //返回
        return temp;
    }

    //--c
    unsignedBigInt operator--() {
        *this = *this - unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c--
    unsignedBigInt operator--(int i) {
        unsignedBigInt temp = *this;
        *this = temp - unsignedBigInt(&quot;1&quot;);
        return temp;
        }

    //乘号
    unsignedBigInt operator*(unsignedBigInt b) {
        unsignedBigInt temp(&quot;0&quot;);
        for (int i = 0; i &lt; strlen(b.ch + b.startNum); i++) {
            int curPos = b.startNum + strlen(b.ch + b.startNum) - 1 - i;
            unsignedBigInt addNum;
            if (b.ch[curPos] != '0') {
                //Accelerate
                int jw = 0;
                for (int j = startNum + strlen(ch+startNum) - 1; j &gt;= startNum || jw != 0; j--) {
                    int c1 = ch[j] == 0 ? 0 : ch[j] - '0';
                    int c2 = b.ch[curPos] == 0 ? 0 : b.ch[curPos] - '0';

                    if (c1*c2 + jw &lt; 10) {
                        addNum.ch[--addNum.startNum] = c1 * c2 + jw + '0';
                        jw = 0;
                    }
                    else {
                        addNum.ch[--addNum.startNum] = (c1*c2 + jw) % 10 + '0';
                        jw = (c1*c2 + jw) / 10;
                    }
                }
                //Calculate
                for (int j = 0; j &lt; i; j++)
                    addNum.ch[addNum.startNum + strlen(addNum.ch + addNum.startNum)] = '0';

                temp = temp + addNum;
            }
        }
        return temp;
    }

    //除号
    unsignedBigInt operator/(unsignedBigInt b) {
        //排除异常
        if (b == unsignedBigInt(&quot;0&quot;)) {
            throw &quot;NaN&quot;;
        }

        //临时被除数
        unsignedBigInt temp;
        //最终结果
        unsignedBigInt result;

        for (int i = startNum; i &lt; startNum + strlen(ch + startNum); i++) {
            //下移一位
            temp.ch[temp.startNum + strlen(temp.ch + temp.startNum)] = ch[i];
            //开始计算
            unsignedBigInt tempResult=b;
            int wr = 0;
            for (; tempResult &lt;= temp;wr++) {
                tempResult = tempResult + b;
            }
            result.ch[result.startNum + strlen(result.ch + result.startNum)] = wr + '0';
            //计算差值
            tempResult = tempResult - b;
            if (tempResult == unsignedBigInt(&quot;0&quot;)) {
                temp = unsignedBigInt();
            }
            else {
                temp = temp - tempResult;
            }
        }

        //去0
        for (; strlen(result.ch + result.startNum) &gt; 1 &amp;&amp; result.ch[result.startNum] == '0';)
            result.ch[result.startNum++] = 0;

        return result;
    }

    //%
    unsignedBigInt operator%(unsignedBigInt b) {
        return *this-*this/b*b;
    }

    //+=
    void operator+=(unsignedBigInt b) {
        *this = *this + b;
    }

    //-=
    void operator-=(unsignedBigInt b) {
        *this = *this - b;
    }

    //*=
    void operator*=(unsignedBigInt b) {
        *this = *this * b;
    }

    // /=
    void operator/=(unsignedBigInt b) {
        *this = *this / b;
    }

    //%=
    void operator%=(unsignedBigInt b) {
        *this = *this% b;
    }
};
*/

//新无符号大整数类

class unsignedBigInt {
private:
    bool del = false;
public:
    char *ch;
    int startNum = 0;
    int len = 0;

    //初始化
    unsignedBigInt(const char *input) {
        if (del)
            delete[] ch;

        len = (strlen(input) + 1) * 2;
        startNum = strlen(input);
        ch = new char[len];
        memset(ch, 0, len);
        for (int i = 0; i &lt; strlen(input); i++)
            ch[i + startNum] = input[i];

        del = true;
    }
    unsignedBigInt(int num) {
        if (del)
            delete[] ch;

        //临时数组
        int n = 0, temp[intMax];
        if (num == 0) {
            n = 1;
            temp[0] = 0;
        }
        else
            for (; num &gt; 0; num /= 10)
                temp[n++] = num % 10;


        len = (n + 1) * 2;
        startNum = n;
        ch = new char[len];
        memset(ch, 0, len);

        for (int i = 0; i &lt; n; i++)
            ch[startNum + i] = temp[n - i - 1] + '0';

        del = true;
    }
    unsignedBigInt(void) {
        if (del)
            delete[] ch;

        len = 1;
        startNum = 0;
        ch = new char[len];
        memset(ch, 0, len);

        del = true;
    }
    unsignedBigInt(int num, int sizen) {
        if (del)
            delete[] ch;

        len = (sizen + 1) * 2;
        startNum = sizen;
        ch = new char[len];
        memset(ch, 0, len);

        if (num &gt;= 0) {
            int n = 0, temp[intMax];
            if (num == 0) {
                n = 1;
                temp[0] = 0;
            }
            else
                for (; num &gt; 0; num /= 10)
                    temp[n++] = num % 10;

            for (int i = 0; i &lt; n; i++)
                ch[startNum + i] = temp[n - i - 1] + '0';
        }

        del = true;
    }

    //析构
    ~unsignedBigInt() {
        if (del)
            delete[] ch;
    }

    //计算真实长度
    int realLength(const unsignedBigInt &amp;b) {
        return strlen(b.ch + b.startNum);
    }

    //复制构造函数
    unsignedBigInt(const unsignedBigInt&amp; b) {
        if (del)
            delete[] ch;

        len = b.len;
        startNum = b.startNum;
        ch = new char[len];
        for (int i = 0; i &lt; len; i++)
            ch[i] = b.ch[i];

        del = true;
    }

    //输入输出
    friend ostream &amp;operator&lt;&lt;(ostream &amp;output, const unsignedBigInt &amp;bi);
    friend istream &amp;operator&gt;&gt;(istream &amp;input, unsignedBigInt &amp;bi);

    //赋值
    unsignedBigInt &amp;operator=(const unsignedBigInt &amp;b) {
        //检查自身赋值
        if (this == &amp;b)
            return *this;

        if (del)
            delete[] ch;

        len = b.len;
        startNum = b.startNum;
        ch = new char[len];
        for (int i = 0; i &lt; len; i++)
            ch[i] = b.ch[i];

        del = true;
        return *this;
    }
    unsignedBigInt &amp;operator=(const char* b) {
        if (del)
            delete[] ch;

        len = (strlen(b) + 1) * 2;
        startNum = strlen(b);
        memset(ch, 0, len);

        for (int i = 0; i &lt; strlen(b); i++)
            ch[i + startNum] = b[i];

        del = true;
        return *this;
    }
    unsignedBigInt &amp;operator=(int num) {
        if (del)
            delete[] ch;

        //临时数组
        int n = 0, temp[intMax];
        if (num == 0) {
            n = 1;
            temp[0] = 0;
        }
        else
            for (; num &gt; 0; num /= 10)
                temp[n++] = num % 10;


        len = (n + 1) * 2;
        startNum = n;
        ch = new char[len];
        memset(ch, 0, len);

        for (int i = 0; i &lt; n; i++)
            ch[startNum + i] = temp[n - i - 1] + '0';

        del = true;
        return *this;
    }

    //比较符
    //小于
    bool operator&lt;(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt; strlen(b.ch + b.startNum) ? true : false;
    }

    //大于
    bool operator&gt;(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt; 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &gt; strlen(b.ch + b.startNum) ? true : false;
    }

    //小于等于
    bool operator&lt;=(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &lt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &lt; strlen(b.ch + b.startNum) ? true : false;
    }

    //大于等于
    bool operator&gt;=(const unsignedBigInt &amp;b) {
        return (strcmp(ch + startNum, b.ch + b.startNum) &gt;= 0 &amp;&amp; strlen(ch + startNum) == strlen(b.ch + b.startNum)) || strlen(ch + startNum) &gt; strlen(b.ch + b.startNum) ? true : false;
    }

    //等于等于
    bool operator==(const unsignedBigInt &amp;b) {
        return strcmp(ch + startNum, b.ch + b.startNum) == 0 ? true : false;
    }

    //运算符
    //加号
    unsignedBigInt operator+(const unsignedBigInt &amp;b) {
        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        int jw = 0;
        int test = realLength(*this);

        for (int i = 0; realLength(*this) &gt; i || realLength(b) &gt; i || jw != 0; i++) {
            //判断加数
            int j1 = realLength(*this) &lt;= i ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2 = realLength(b) &lt;= i ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            temp.ch[--temp.startNum] = (j1 + j2 + jw) % 10 + '0';
            jw = (j1 + j2 + jw) / 10;
        }

        //返回
        return temp;
    }

    //++c
    unsignedBigInt operator++() {
        *this = *this + unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c++
    unsignedBigInt operator++(int i) {
        unsignedBigInt temp = *this;
        *this = temp + unsignedBigInt(&quot;1&quot;);
        return temp;
    }

    //减号
    unsignedBigInt operator-(const unsignedBigInt &amp;b) {
        if (*this == b)
            return unsignedBigInt(0);

        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        int jw = 0;

        for (int i = 0; realLength(*this) &gt; i || realLength(b) &gt; i; i++) {
            //判断被减数与减数
            int j1 = realLength(*this) &lt;= i ? 0 : ch[startNum + strlen(ch + startNum) - i - 1] - '0';
            int j2 = realLength(b) &lt;= i ? 0 : b.ch[b.startNum + strlen(b.ch + b.startNum) - i - 1] - '0';

            //运算
            if (j1 - jw - j2 &lt; 0) {
                temp.ch[--temp.startNum] = 10 + j1 - jw - j2 + '0';
                jw = 1;
            }
            else {
                temp.ch[--temp.startNum] = j1 - jw - j2 + '0';
                jw = 0;
            }
        }

        //修正
        for (; temp.ch[temp.startNum] == '0';)
            temp.ch[temp.startNum++] = 0;

        //返回
        return temp;
    }

    //--c
    unsignedBigInt operator--() {
        *this = *this - unsignedBigInt(&quot;1&quot;);
        return *this;
    }

    //c--
    unsignedBigInt operator--(int i) {
        unsignedBigInt temp = *this;
        *this = temp - unsignedBigInt(&quot;1&quot;);
        return temp;
    }

    //乘号
    unsignedBigInt operator*(const unsignedBigInt &amp;b) {
        unsignedBigInt temp(0, realLength(*this) + realLength(b) + 2);
        for (int i = 0; i &lt; strlen(b.ch + b.startNum); i++) {
            int curPos = b.startNum + strlen(b.ch + b.startNum) - 1 - i;
            unsignedBigInt addNum(-1, realLength(*this) + realLength(b) + 2);
            if (b.ch[curPos] != '0') {
                //Accelerate
                int jw = 0;
                for (int j = startNum + strlen(ch + startNum) - 1; j &gt;= startNum || jw != 0; j--) {
                    int c1 = ch[j] == 0 ? 0 : ch[j] - '0';
                    int c2 = b.ch[curPos] == 0 ? 0 : b.ch[curPos] - '0';

                    if (c1*c2 + jw &lt; 10) {
                        addNum.ch[--addNum.startNum] = c1 * c2 + jw + '0';
                        jw = 0;
                    }
                    else {
                        addNum.ch[--addNum.startNum] = (c1*c2 + jw) % 10 + '0';
                        jw = (c1*c2 + jw) / 10;
                    }
                }
                //Calculate
                for (int j = 0; j &lt; i; j++)
                    addNum.ch[addNum.startNum + strlen(addNum.ch + addNum.startNum)] = '0';

                temp = temp + addNum;
            }
        }
        return temp;
    }

    //除号
    unsignedBigInt operator/(const unsignedBigInt &amp;b) {
        //排除异常
        if (unsignedBigInt(&quot;0&quot;) == b) {
            throw &quot;NaN&quot;;
        }

        //临时被除数
        unsignedBigInt temp(-1, max(realLength(*this), realLength(b)) + 2);
        //最终结果
        unsignedBigInt result(-1, max(realLength(*this), realLength(b)) + 2);

        for (int i = startNum; i &lt; startNum + strlen(ch + startNum); i++) {
            //下移一位
            temp.ch[temp.startNum + strlen(temp.ch + temp.startNum)] = ch[i];
            //开始计算
            unsignedBigInt tempResult = b;
            int wr = 0;
            for (; tempResult &lt;= temp; wr++) {
                tempResult = tempResult + b;
            }
            result.ch[result.startNum + strlen(result.ch + result.startNum)] = wr + '0';
            //计算差值
            tempResult = tempResult - b;
            if (tempResult == temp) {
                temp = unsignedBigInt(-1, max(realLength(*this), realLength(b)) + 2);
            }
            else {
                temp = temp - tempResult;
            }
        }

        //去0
        for (; strlen(result.ch + result.startNum) &gt; 1 &amp;&amp; result.ch[result.startNum] == '0';)
            result.ch[result.startNum++] = 0;

        return result;
    }

    //%
    unsignedBigInt operator%(const unsignedBigInt &amp;b) {
        return *this - *this / b * b;
    }

    //+=
    void operator+=(const unsignedBigInt &amp;b) {
        *this = *this + b;
    }

    //-=
    void operator-=(const unsignedBigInt &amp;b) {
        *this = *this - b;
    }

    //*=
    void operator*=(const unsignedBigInt &amp;b) {
        *this = *this * b;
    }

    // /=
    void operator/=(const unsignedBigInt &amp;b) {
        *this = *this / b;
    }

    //%=
    void operator%=(const unsignedBigInt &amp;b) {
        *this = *this% b;
    }
};


//有符号大整数类
class bigInt {
public:
    bool op = true;
    unsignedBigInt ubi;

    //构造函数
    bigInt() {
        ubi = unsignedBigInt();
    }
    bigInt(const char* b) {
        if (b[0] == '-') {
            ubi = unsignedBigInt(b + 1);
            op = false;
        }
        else {
            ubi = unsignedBigInt(b);
            op = true;
        }
    }
    bigInt(int b) {
        if (b &lt; 0) {
            ubi = unsignedBigInt(-b);
            op = false;
        }
        else {
            ubi = unsignedBigInt(b);
            op = true;
        }
    }
    bigInt(int num, int sizen) {
        if (num &lt; 0) {
            ubi = unsignedBigInt(-num, sizen);
            op = false;
        }
        else {
            ubi = unsignedBigInt(num, sizen);
            op = true;
        }
    }

    //复制函数
    bigInt(const bigInt &amp;b) {
        op = b.op;
        ubi = b.ubi;
    }

    //赋值函数
    bigInt &amp;operator=(const bigInt &amp;b) {
        op = b.op;
        ubi = b.ubi;

        return *this;
    }
    bigInt &amp;operator=(const char* b) {
        if (b[0] == '-') {
            ubi = unsignedBigInt(b + 1);
            op = false;
        }
        else {
            ubi = unsignedBigInt(b);
            op = true;
        }

        return *this;
    }
    bigInt &amp;operator=(int b) {
        if (b &lt; 0) {
            ubi = unsignedBigInt(-b);
            op = false;
        }
        else {
            ubi = unsignedBigInt(b);
            op = true;
        }

        return *this;
    }

    //比较部分
    //大于
    bool operator&gt;(const bigInt &amp;b) {
        if (op != b.op)
            return op &gt; b.op ? true : false;
        else
            return op ? ubi &gt; b.ubi:ubi &lt; b.ubi;
    }
    //大于等于
    bool operator&gt;=(const bigInt &amp;b) {
        if (op != b.op)
            return op &gt; b.op ? true : false;
        else
            return op ? ubi &gt;= b.ubi : ubi &lt;= b.ubi;
    }
    //小于
    bool operator&lt;(const bigInt &amp;b) {
        if (op != b.op)
            return op &lt; b.op ? true : false;
        else
            return op ? ubi &lt; b.ubi : ubi &gt; b.ubi;
    }
    //小于等于
    bool operator&lt;=(const bigInt &amp;b) {
        if (op != b.op)
            return op &lt; b.op ? true : false;
        else
            return op ? ubi &lt;= b.ubi : ubi &gt;= b.ubi;
    }
    //等于等于
    bool operator==(const bigInt &amp;b) {
        return op == b.op || ubi == unsignedBigInt(0) ? ubi == b.ubi : false;
    }
    //不等于
    bool operator!=(const bigInt &amp;b) {
        return !(*this == b);
    }

    //计算部分
    //加法
    bigInt operator+(const bigInt &amp;b) {
        bigInt result;

        if (op == b.op) {
            result.ubi = ubi + b.ubi;
            result.op = op;
        }
        else if (op &gt; b.op) {
            if (ubi &gt;= b.ubi) {
                result.ubi = ubi - b.ubi;
                result.op = true;
            }
            else {
                unsignedBigInt temp = b.ubi;
                result.ubi = temp - ubi;
                result.op = false;
            }
        }
        else {
            if (ubi &gt; b.ubi) {
                result.ubi = ubi - b.ubi;
                result.op = false;
            }
            else {
                unsignedBigInt temp = b.ubi;
                result.ubi = temp - ubi;
                result.op = true;
            }
        }

        return result;
    }
    //减法
    bigInt operator-(const bigInt &amp;b) {
        bigInt temp = b;
        temp.op = !temp.op;
        return *this + temp;
    }
    //负号
    bigInt operator-() {
        return bigInt(0) - *this;
    }
    //乘法
    bigInt operator*(const bigInt &amp;b) {
        bigInt result;

        if (op == b.op) {
            result.ubi = ubi * b.ubi;
            result.op = true;
        }
        else {
            result.ubi = ubi * b.ubi;
            result.op = false;
        }

        return result;
    }
    //除法
    bigInt operator/(const bigInt &amp;b) {
        bigInt result;

        if (op == b.op) {
            result.ubi = ubi / b.ubi;
            result.op = true;
        }
        else {
            result.ubi = ubi / b.ubi;
            result.op = false;
        }

        return result;
    }
    //%
    bigInt operator%(const bigInt &amp;b) {
        return *this - *this / b * b;
    }

    //++c
    bigInt operator++() {
        *this = *this + bigInt(1);
    }
    //c++
    bigInt operator++(int b) {
        *this = *this + bigInt(b);
        return *this - bigInt(b);
    }
    //--c
    bigInt operator--() {
        *this = *this - bigInt(1);
    }
    //c--
    bigInt operator--(int b) {
        *this = *this - bigInt(b);
        return *this + bigInt(b);
    }

    //+=
    void operator+=(const bigInt &amp;b) {
        *this = *this + b;
    }
    //-=
    void operator-=(const bigInt &amp;b) {
        *this = *this - b;
    }
    //*=
    void operator*=(const bigInt &amp;b) {
        *this = *this * b;
    }
    // /=
    void operator/=(const bigInt &amp;b) {
        *this = *this / b;
    }
    //%=
    void operator%=(const bigInt &amp;b) {
        *this = *this % b;
    }
};

//输入输出流重载
//无符号大整数
ostream &amp;operator&lt;&lt;(ostream &amp;output, const unsignedBigInt &amp;bi) {
    output &lt;&lt; bi.ch + bi.startNum;
    return output;
}
istream &amp;operator&gt;&gt;(istream &amp;input, unsignedBigInt &amp;bi) {
    char ch[maxNum];
    input &gt;&gt; ch;
    bi = unsignedBigInt(ch);
    return input;
}

//有符号大整数
ostream &amp;operator&lt;&lt;(ostream &amp;output, const bigInt &amp;bi) {
    output &lt;&lt; (!bi.op ? &quot;-&quot; : &quot;&quot;) &lt;&lt; bi.ubi;
    return output;
}
istream &amp;operator&gt;&gt;(istream &amp;input, bigInt &amp;bi) {
    input &gt;&gt; bi.ubi;
    if (bi.ubi.ch[bi.ubi.startNum] == '-') {
        bi.op = false;
        bi.ubi.ch[bi.ubi.startNum++] = 0;
    }
    return input;
}

int main() {
    bigInt a, b;
    cin &gt;&gt; a &gt;&gt; b;
    a /= b;
    cout &lt;&lt; a;
    return 0;
}
</code></pre>

<h2 id="neight99s-solution">Neight99's solution <a class="github-button" href="https://github.com/Neight99/SJTU_DataStructure_A" data-icon="octicon-star" data-show-count="true" aria-label="有启发？给大佬星！"></a></h2>
<pre><code>#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;

class num {
    struct node {
        int data;
        node *next;

        node() : next(NULL) {}

        node(int d, node *N = NULL) : data(d), next(N) {}
    };

    node *head;

   public:
    int len;

    num();

    num(const num &amp;other);

    num(int x);

    ~num();

    void show();

    void operate(num &amp;b);

    int sub(num &amp;b);

    void add(num &amp;b);

    void force();
};

void num::add(num &amp;b) {
    int carry = 0, tem;
    node *cur1 = head;
    node *cur2 = b.head;
    while (cur1-&gt;next &amp;&amp; cur2-&gt;next) {
        tem = carry + cur1-&gt;data + cur2-&gt;data;
        if (tem &gt;= 10) {
            carry = 1;
            tem -= 10;
        } else {
            carry = 0;
        }
        cur1-&gt;data = tem;
        cur1 = cur1-&gt;next;
        cur2 = cur2-&gt;next;
    }

    while (cur1-&gt;next) {
        tem = carry + cur1-&gt;data;
        if (tem &gt;= 10) {
            carry = 1;
            tem -= 10;
        } else {
            carry = 0;
        }
        cur1-&gt;data = tem;
        cur1 = cur1-&gt;next;
    }

    while (cur2-&gt;next) {
        tem = carry + cur2-&gt;data;
        if (tem &gt;= 10) {
            carry = 1;
            tem -= 10;
        } else {
            carry = 0;
        }
        cur1-&gt;data = tem;
        cur1 = cur1-&gt;next = new node();
        cur2 = cur2-&gt;next;
    }

    if (carry) {
        cur1-&gt;data = carry;
        cur1-&gt;next = new node();
    }
}

void num::force() {
    ++len;
    head = new node(0, head);
}

num::num(int x) {
    len = 1;
    head = new node();
    head = new node(x, head);
}

num::num(const num &amp;other) {
    len = 0;
    node *p = other.head;
    head = new node(p-&gt;data);
    node *cur = head;

    while (1) {
        p = p-&gt;next;
        if (!p) {
            break;
        }
        cur = cur-&gt;next = new node(p-&gt;data);
    }

    len = other.len;
}

void num::show() {
    node *cur = head;
    while (cur-&gt;next) {
        cout &lt;&lt; cur-&gt;data;
        cur = cur-&gt;next;
    }
}

void num::operate(num &amp;b) {
    num ans(0);
    node *cur;
    int d, flag;

    while (1) {
        num tem(b), addin(1);
        d = max(0, len - b.len - 1);

        for (int i = 0; i &lt; d; ++i) {
            tem.force();
        }

        flag = sub(tem);

        if (flag) {
            for (int i = 0; i &lt; d; ++i) {
                addin.force();
            }

            ans.add(addin);
        } else {
            break;
        }
    }
    node *out = NULL;
    cur = ans.head;
    while (cur-&gt;next) {
        out = new node(cur-&gt;data, out);
        cur = cur-&gt;next;
    }

    while (out) {
        cout &lt;&lt; out-&gt;data;
        cur = out;
        out = out-&gt;next;
        delete cur;
    }
}

int num::sub(num &amp;b) {
    node *cur1 = head;
    node *cur2 = b.head;
    int lend = 0, tem, last0;

    if (len &lt; b.len) {
        return 0;
    }

    while (cur1-&gt;next &amp;&amp; cur2-&gt;next) {
        tem = cur1-&gt;data - cur2-&gt;data - lend;
        if (tem &lt; 0) {
            lend = 1;
            tem += 10;
        } else {
            lend = 0;
        }
        cur1-&gt;data = tem;
        cur1 = cur1-&gt;next;
        cur2 = cur2-&gt;next;
    }

    while (cur1-&gt;next) {
        tem = cur1-&gt;data - lend;
        if (tem &lt; 0) {
            lend = 1;
            tem += 10;
        } else {
            lend = 0;
        }
        cur1-&gt;data = tem;
        cur1 = cur1-&gt;next;
    }

    if (!cur1-&gt;next &amp;&amp; !cur2-&gt;next &amp;&amp; lend) {
        return 0;
    } else {
        cur1 = head;
        while (cur1-&gt;next) {
            if (cur1-&gt;data != 0) {
                last0 = 0;
            } else {
                ++last0;
            }
            cur1 = cur1-&gt;next;
        }

        cur1 = head;

        for (int i = 0; i &lt; len - last0 - 1; ++i) {
            cur1 = cur1-&gt;next;
        }

        for (int i = 0; i &lt; last0; ++i) {
            cur2 = cur1-&gt;next;
            if (!cur2-&gt;next) {
                break;
            }
            cur1-&gt;next = cur2-&gt;next;
            delete cur2;
        }

        len -= last0;
    }
    return 1;
}

num::num() {
    len = 0;
    head = new node;
    char ch;
    while (1) {
        cin.get(ch);
        if (ch == '\n') break;
        head = new node(ch - '0', head);
        ++len;
    }
}

num::~num() {
    if (len &gt; 0) {
        node *cur = head;
        while (head) {
            head = head-&gt;next;
            delete cur;
            cur = head;
        }
    }
}

int main() {
    num n1, n2;
    n1.operate(n2);
    return 0;
}

</code></pre>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
    
  </body>
</html>